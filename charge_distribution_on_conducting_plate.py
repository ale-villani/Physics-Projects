import numpy as np
import matplotlib.pyplot as plt

# Physical Constants
R = 2.0  # Radius of the disk in meters
epsilon_0 = 8.854e-12  
V0 = 1.0   # Fixed potential of the disk
k_coulomb = 1 / (4 * np.pi * epsilon_0)

# To integrate numerically, dividing the disk into a grid of square cells
N_grid = 120   # Number of cells per side of the square (which contains the disk)
L_box = 2 * R 
dx = L_box / N_grid
area = dx**2  # Area of each cell

# Create Squares grid
x = np.linspace(-L_box/2, L_box/2, N_grid)
y = np.linspace(-L_box/2, L_box/2, N_grid)
X, Y = np.meshgrid(x, y)

# Mask: select only points within the disk
R_dist = np.sqrt(X**2 + Y**2)
mask = R_dist < R  
X_disk = X[mask]
Y_disk = Y[mask]
N = len(X_disk) # Number of effective unknowns

print(f"Solving for {N} elements...")

# Calculate distances between squares using the distance matrix
x_vec = X_disk[:, np.newaxis] # Column vector
y_vec = Y_disk[:, np.newaxis]
dist_sq = (x_vec - x_vec.T)**2 + (y_vec - y_vec.T)**2 
dist_matrix = np.sqrt(dist_sq) # Distance matrix r_ij

# Initialize M, matrix of known terms
M = np.zeros((N, N))


# For off-diagonal terms of A (i != j) consider the charge as point-like concentrated at the center of the square
M = k_coulomb * area / dist_matrix

# For diagonal terms (i == j) the potential can be calculated as generated by a charge uniformly distributed at the center of the square
# If the square has side a, the potential at the center is given by:
# V(0, 0) = (sigma*/(4*pi*epsilon_0)) * (4*a*ln(1 + sqrt(2)))
np.fill_diagonal(M, k_coulomb * (4 * np.log(1 + np.sqrt(2))) * dx)


# To estimate the charge distribution, setting the potential of each square to V0 
# (uniform because conductor is in equilibrium)
V_vec = np.full(N, V0)

# Solve for the total charges q on each pixel
Sigma = np.linalg.solve(M, V_vec)

# Construction of the 2D plot
sigma_grid = np.full((N_grid, N_grid), np.nan)
sigma_grid[mask] = Sigma

# Total Charge Calculation
Q_tot = np.sum(Sigma)*(dx**2)

print(f"Calculated Total Charge: {Q_tot:.4e} C")

# Plot
plt.figure(figsize=(10, 8))
plt.rc('text', usetex=True)
plt.imshow(sigma_grid, origin='lower', extent=[-L_box/2, L_box/2, -L_box/2, L_box/2], cmap='inferno')
plt.colorbar(label=r'Charge density $\sigma$ [C/m$^2$]')
plt.title(f'Charge Distribution on Conducting Disk at Equilibrium\nQ_calc = {Q_tot:.2e} C')
plt.xlabel('x [m]')
plt.ylabel('y [m]')
plt.show()

# Plot sigma(r)
# Taking points close to y=0
radial_cells_mask = (np.abs(Y_disk) < dx) & (X_disk > 0)
r = X_disk[radial_cells_mask]
sigma_radial = Sigma[radial_cells_mask]
plt.figure(figsize=(8, 4))
plt.scatter(r, sigma_radial, s=10, c='red')
plt.title("Charge as a function of radius $r$")
plt.xlabel("r [m]")
plt.ylabel(r"$\sigma$ [C/m$^2$]")
plt.grid(True, alpha=0.3)
plt.show()

#Calculating the potential in space
def V (x, y, z):
    V_tot = 0
    for i in range (N):
        r_i = np.sqrt((x - X_disk[i])**2 + (y - Y_disk[i])**2 + z**2)
        V_tot += k_coulomb * Sigma[i] * area / r_i
    return V_tot

# Plotting V(z) in a perpendicular plane above the center of the disk
x_space = np.linspace(-4, 4, 100)
z_space = np.linspace(-4, 4, 100)
X_plane, Z_plane = np.meshgrid(x_space, z_space)
Y_plane = np.zeros_like(X_plane)
V_plane = V(X_plane, Y_plane, Z_plane)

# Creating a heatmap of V(x, z) at y=0
plt.figure(figsize=(10, 8))
plt.imshow(V_plane, origin='lower', extent=[-2*R, 2*R, 0, 2*R], cmap='viridis', aspect='auto')
plt.colorbar(label='Potential V [V]')
plt.title('Electric Potential V(x, z) above the Center of the Disk (y=0)')
plt.xlabel('x [m]')
plt.ylabel('z [m]')
plt.show()  

# Computing the electric field in the same plane
Ex = np.zeros_like(X_plane)
Ez = np.zeros_like(Z_plane)

for i in range(X_plane.shape[0]):
    for j in range(X_plane.shape[1]):
        x1, z1 = X_plane[i, j], Z_plane[i, j]
        rx = x1 - X_disk
        ry = - Y_disk
        rz = z1
        r_mag = np.sqrt(rx**2 + ry**2 + rz**2)

        common = k_coulomb * Sigma / r_mag**3
        Ex[i, j] = np.sum(common * rx)
        Ez[i, j] = np.sum(common * rz)

# Electric field lines
plt.figure(figsize=(12, 8))
quiv = plt.quiver(X_plane, Z_plane, Ex, Ez, color='C0', angles='xy', scale_units='xy')
plt.plot([-R, R], [0, 0], color='C1', linewidth=4, label='Disco Conduttore')
plt.title('Electrostatic Field Distribution (XZ plane)')
plt.xlabel('x [m]')
plt.ylabel('z [m]')
plt.show()
